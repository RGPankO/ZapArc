// Background service worker for Lightning Network Tipping Extension
// Handles Breez SDK operations, storage management, and message passing

import { WalletData, UserSettings } from '../types';
import { WalletManager } from '../utils/wallet-manager';
import { ChromeStorageManager } from '../utils/storage';
import { LnurlManager } from '../utils/lnurl';
import * as bip39 from 'bip39';

// Breez SDK API key (client certificate for Spark implementation)
// This is a client certificate provided by Breez for authentication
const BREEZ_API_KEY = 'MIIBfjCCATCgAwIBAgIHPoqCRCUxZzAFBgMrZXAwEDEOMAwGA1UEAxMFQnJlZXowHhcNMjUxMDEzMTY0NzQ0WhcNMzUxMDExMTY0NzQ0WjAwMRUwEwYDVQQKEwxCVEMgSE9ETCBMdGQxFzAVBgNVBAMTDlBsYW1lbiBBbmRvbm92MCowBQYDK2VwAyEA0IP1y98gPByiIMoph1P0G6cctLb864rNXw1LRLOpXXejgYgwgYUwDgYDVR0PAQH/BAQDAgWgMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFNo5o+5ea0sNMlW/75VgGJCv2AcJMB8GA1UdIwQYMBaAFN6q1pJW843ndJIW/Ey2ILJrKJhrMCUGA1UdEQQeMByBGnBsYW1lbkBjcnlwdG9yZXZvbHV0aW9uLmJnMAUGAytlcANBAOxPxCDCzt/batCHrDuIMNsZL0lqBpk/dG+MzqseJRS8UjhJsSpOO4jTtsMqS7DWJE64THyIV+FTCbt1XhUM2A4=';

console.log('Lightning Tipping Extension background service worker loaded');

// Global instances
const walletManager = new WalletManager();
const storageManager = new ChromeStorageManager();
const lnurlManager = new LnurlManager(walletManager);

/**
 * Generate a 12-word BIP39 mnemonic phrase
 * Uses the standard BIP39 wordlist (2048 words)
 */
function generateMnemonic(): string {
  return bip39.generateMnemonic();
}

// Message handler for communication with other components
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  handleMessage(message, sender, sendResponse);
  return true; // Keep message channel open for async responses
});

async function handleMessage(message: any, sender: any, sendResponse: (response: any) => void) {
  try {
    // Update activity timestamp for auto-lock
    await storageManager.updateActivity();

    switch (message.type) {
      case 'GENERATE_MNEMONIC':
        try {
          // Generate a new mnemonic phrase
          const mnemonic = generateMnemonic();
          console.log('Background: Generated mnemonic phrase');
          sendResponse({ success: true, data: mnemonic });
        } catch (error) {
          console.error('Background: Mnemonic generation failed:', error);
          sendResponse({
            success: false,
            error: error instanceof Error ? error.message : 'Mnemonic generation failed'
          });
        }
        break;

      case 'SETUP_WALLET':
        try {
          console.log('Background: Starting wallet setup (storage only)');

          // Validate mnemonic
          if (!bip39.validateMnemonic(message.mnemonic)) {
            throw new Error('Invalid mnemonic phrase');
          }

          // Get user settings
          const settings = await storageManager.getUserSettings();

          // Create wallet data WITHOUT Breez SDK (SDK runs in popup)
          const walletData: WalletData = {
            mnemonic: message.mnemonic,
            balance: 0,  // Will be updated by popup after SDK initialization
            lnurl: undefined,  // Will be generated by popup after SDK initialization
            customLNURL: settings.customLNURL,
            transactions: []
          };

          // Save encrypted wallet data
          await storageManager.saveEncryptedWallet(walletData, message.pin);
          await storageManager.unlockWallet();

          console.log('Background: Wallet data saved successfully');
          sendResponse({
            success: true,
            message: 'Wallet created. SDK will be initialized in popup.'
          });
        } catch (setupError) {
          console.error('Background: Wallet setup failed:', setupError);
          sendResponse({
            success: false,
            error: setupError instanceof Error ? setupError.message : 'Wallet setup failed'
          });
        }
        break;

      case 'UNLOCK_WALLET':
        // Don't try to connect SDK in background - just update storage flags
        await chrome.storage.local.set({
          isUnlocked: true,
          lastActivity: Date.now()
        });
        console.log('[Background] Wallet marked as unlocked in storage');
        sendResponse({ success: true });
        break;

      case 'LOCK_WALLET':
        // Storage-only operation
        await chrome.storage.local.set({
          isUnlocked: false
        });
        console.log('[Background] Wallet locked');
        sendResponse({ success: true });
        break;

      case 'GET_WALLET_STATUS':
        const status = await walletManager.getWalletStatus();
        sendResponse({ success: true, status });
        break;

      case 'GET_BALANCE':
        // Return cached balance from storage
        const cachedData = await chrome.storage.local.get(['cachedBalance']);
        sendResponse({
          success: true,
          data: cachedData.cachedBalance || 0,
          cached: true
        });
        break;

      case 'GENERATE_INVOICE':
        // Invoice generation now happens in popup context (SDK requires DOM/WASM)
        // This case is kept for backward compatibility but should not be used
        console.warn('GENERATE_INVOICE called in background - should be handled in popup');
        sendResponse({
            success: false,
            error: 'Invoice generation must be done in popup. Please ensure popup is open.',
            requiresPopup: true
        });
        break;

      case 'SEND_PAYMENT':
        // SDK operation - must be done in popup
        console.warn('[Background] SEND_PAYMENT requires popup SDK');
        sendResponse({
          success: false,
          error: 'Sending payments requires popup context. Please open extension popup.',
          requiresPopup: true
        });
        break;

      case 'LIST_PAYMENTS':
        // SDK operation - must be done in popup
        console.warn('[Background] LIST_PAYMENTS requires popup SDK - returning empty array');
        sendResponse({
          success: false,
          error: 'Payment history requires popup context. Please open extension popup.',
          data: []
        });
        break;

      case 'PARSE_LNURL':
        const parsed = await walletManager.parseLnurl(message.lnurl);
        sendResponse({ success: true, data: parsed });
        break;

      case 'PAY_LNURL':
        const paySuccess = await walletManager.payLnurl(message.reqData, message.amount, message.comment);
        sendResponse({ success: paySuccess });
        break;

      case 'PROCESS_PAYMENT':
        try {
          // This would integrate with the payment processor
          const paymentResult = await walletManager.payLnurl(
            message.lnurlData, 
            message.amount, 
            message.comment
          );
          sendResponse({ 
            success: paymentResult,
            transactionId: paymentResult ? `tx_${Date.now()}` : undefined
          });
        } catch (error) {
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Payment processing failed',
            retryable: true
          });
        }
        break;

      case 'GENERATE_QR_CODE':
        try {
          // For QR code generation, we return the LNURL or bolt11 invoice
          // The frontend will handle the actual QR image generation
          let qrData = message.lnurl;
          
          if (message.amount && message.amount > 0) {
            // If amount is specified, we could generate a bolt11 invoice
            // For now, return the LNURL with amount parameter
            qrData = `lightning:${message.lnurl.toUpperCase()}?amount=${message.amount * 1000}`;
            if (message.comment) {
              qrData += `&message=${encodeURIComponent(message.comment)}`;
            }
          }
          
          sendResponse({ success: true, qrData });
        } catch (error) {
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'QR generation failed'
          });
        }
        break;

      case 'GENERATE_LNURL':
        const lnurl = await walletManager.generateReceiveLnurl();
        sendResponse({ success: true, lnurl });
        break;

      case 'GET_NODE_INFO':
        const nodeInfo = await walletManager.getNodeInfo();
        sendResponse({ success: true, nodeInfo });
        break;

      case 'CHECK_SUFFICIENT_BALANCE':
        const hasSufficientBalance = await walletManager.hasSufficientBalance(message.amount);
        sendResponse({ success: true, hasSufficientBalance });
        break;

      case 'PARSE_TIP_REQUEST':
        const tipData = lnurlManager.parseTipRequest(message.tipString);
        sendResponse({ success: true, tipData });
        break;

      case 'GENERATE_TIP_REQUEST':
        const tipRequest = lnurlManager.generateTipRequest(message.lnurl, message.amounts);
        sendResponse({ success: true, tipRequest });
        break;

      case 'GENERATE_USER_TIP_REQUEST':
        const userTipRequest = await lnurlManager.generateUserTipRequest(message.amounts);
        sendResponse({ success: true, tipRequest: userTipRequest });
        break;

      case 'GET_LNURL_PAYMENT_LIMITS':
        const limits = await lnurlManager.getLnurlPaymentLimits(message.lnurl);
        sendResponse({ success: true, limits });
        break;

      case 'IS_COMMENT_ALLOWED':
        const commentInfo = await lnurlManager.isCommentAllowed(message.lnurl);
        sendResponse({ success: true, commentInfo });
        break;

      case 'EXTRACT_LNURL':
        const extractedLnurl = lnurlManager.extractLnurl(message.input);
        sendResponse({ success: true, lnurl: extractedLnurl });
        break;

      case 'ADD_TO_BLACKLIST':
        const blacklistArray = await storageManager.getBlacklist();
        if (!blacklistArray.lnurls.includes(message.lnurl)) {
          blacklistArray.lnurls.push(message.lnurl);
          blacklistArray.lastUpdated = Date.now();
          await storageManager.saveBlacklist(blacklistArray.lnurls);
        }
        sendResponse({ success: true });
        break;

      case 'REMOVE_FROM_BLACKLIST':
        const currentBlacklist = await storageManager.getBlacklist();
        const filteredLnurls = currentBlacklist.lnurls.filter(lnurl => lnurl !== message.lnurl);
        await storageManager.saveBlacklist(filteredLnurls);
        sendResponse({ success: true });
        break;

      case 'CLEAR_BLACKLIST':
        await storageManager.saveBlacklist([]);
        sendResponse({ success: true });
        break;

      case 'SET_DOMAIN_STATUS':
        await storageManager.saveDomainSettings(message.domain, message.status);
        sendResponse({ success: true });
        break;

      case 'GET_DOMAIN_STATUS':
        const currentDomainSettings = await storageManager.getDomainSettings();
        const domainStatus = currentDomainSettings[message.domain] || 'unmanaged';
        sendResponse({ success: true, status: domainStatus });
        break;

      case 'GET_ALL_DOMAINS':
        const allDomainSettings = await storageManager.getDomainSettings();
        sendResponse({ success: true, domains: allDomainSettings });
        break;

      case 'SAVE_WALLET':
        await storageManager.saveEncryptedWallet(message.walletData, message.pin);
        sendResponse({ success: true });
        break;

      case 'LOAD_WALLET':
        console.log('ðŸ”µ [Background] LOAD_WALLET - PIN received, length:', message.pin?.length);
        const walletData = await storageManager.loadEncryptedWallet(message.pin);
        console.log('âœ… [Background] LOAD_WALLET - Wallet decrypted successfully');
        console.log('ðŸ” [Background] LOAD_WALLET - Response property:', { hasData: !!walletData, hasMnemonic: !!walletData?.mnemonic });
        // FIX: Changed from walletData to data to match popup expectation
        sendResponse({ success: true, data: walletData });
        break;

      case 'SAVE_DOMAIN_SETTINGS':
        await storageManager.saveDomainSettings(message.domain, message.status);
        sendResponse({ success: true });
        break;

      case 'GET_DOMAIN_SETTINGS':
        const domainSettings = await storageManager.getDomainSettings();
        sendResponse({ success: true, domainSettings });
        break;

      case 'SAVE_BLACKLIST':
        await storageManager.saveBlacklist(message.lnurls);
        sendResponse({ success: true });
        break;

      case 'GET_BLACKLIST':
        const blacklist = await storageManager.getBlacklist();
        sendResponse({ success: true, blacklist });
        break;

      case 'GET_USER_SETTINGS':
        const settings = await storageManager.getUserSettings();
        sendResponse({ success: true, data: settings });
        break;

      case 'SAVE_USER_SETTINGS':
        await storageManager.saveUserSettings(message.settings);
        sendResponse({ success: true });
        break;

      case 'IS_WALLET_UNLOCKED':
        const isUnlocked = await storageManager.isWalletUnlocked();
        sendResponse({ success: true, isUnlocked });
        break;



      case 'IS_WALLET_CONNECTED':
        const isConnected = walletManager.getBreezSDK().isWalletConnected();
        sendResponse({ success: true, data: isConnected });
        break;

      case 'WALLET_EXISTS':
        const walletExists = await storageManager.walletExists();
        sendResponse({ success: true, data: walletExists });
        break;

      case 'OPEN_POPUP':
        // Open extension popup
        try {
          await chrome.action.openPopup();
          sendResponse({ success: true });
        } catch (error) {
          // Fallback: open popup in new tab if openPopup fails
          const popupUrl = chrome.runtime.getURL('popup.html');
          await chrome.tabs.create({ url: popupUrl });
          sendResponse({ success: true });
        }
        break;

      case 'OPEN_POPUP_DEPOSIT':
        // Open extension popup with deposit focus
        try {
          await chrome.action.openPopup();
          // Send message to popup to focus on deposit
          setTimeout(() => {
            chrome.runtime.sendMessage({ type: 'FOCUS_DEPOSIT' });
          }, 100);
          sendResponse({ success: true });
        } catch (error) {
          // Fallback: open popup in new tab
          const popupUrl = chrome.runtime.getURL('popup.html?action=deposit');
          await chrome.tabs.create({ url: popupUrl });
          sendResponse({ success: true });
        }
        break;

      case 'OPEN_POPUP_WITHDRAW':
        // Open extension popup with withdraw focus
        try {
          await chrome.action.openPopup();
          // Send message to popup to focus on withdraw
          setTimeout(() => {
            chrome.runtime.sendMessage({ type: 'FOCUS_WITHDRAW' });
          }, 100);
          sendResponse({ success: true });
        } catch (error) {
          // Fallback: open popup in new tab
          const popupUrl = chrome.runtime.getURL('popup.html?action=withdraw');
          await chrome.tabs.create({ url: popupUrl });
          sendResponse({ success: true });
        }
        break;

      default:
        sendResponse({ success: false, error: 'Unknown message type' });
    }
  } catch (error) {
    console.error('Message handler error:', error);
    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
  }
}

// Skip Breez SDK initialization in background service worker
// (WASM modules need DOM context which isn't available here)
console.log('Background service worker ready - Breez SDK will be initialized when needed');

// Auto-lock check on service worker activation
chrome.runtime.onStartup.addListener(async () => {
  try {
    const isUnlocked = await storageManager.isWalletUnlocked();
    if (!isUnlocked) {
      // Just ensure wallet is locked in storage
      await storageManager.lockWallet();
    }
  } catch (error) {
    console.error('Failed to check auto-lock on startup:', error);
  }
});

// ========== AUTO-LOCK TIMER USING CHROME.ALARMS ==========
// Chrome extension Manifest V3 service workers cannot use persistent setTimeout/setInterval
// Must use chrome.alarms API which survives service worker sleep cycles

const AUTO_LOCK_DELAY_MS = 15 * 60 * 1000; // 15 minutes
const ALARM_NAME = 'wallet-auto-lock';

// Create alarm when wallet is unlocked
async function startAutoLockAlarm() {
  console.log('[AutoLock] Starting alarm - will check every minute');

  // Create alarm that fires every 1 minute
  await chrome.alarms.create(ALARM_NAME, {
    periodInMinutes: 1 // Check every minute
  });
}

// Clear alarm when wallet is locked
async function stopAutoLockAlarm() {
  console.log('[AutoLock] Stopping alarm');
  await chrome.alarms.clear(ALARM_NAME);
}

// Handle alarm events - check if wallet should be auto-locked
chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name !== ALARM_NAME) return;

  try {
    // Get current unlock status and last activity
    const data = await chrome.storage.local.get(['isUnlocked', 'lastActivity']);

    if (!data.isUnlocked) {
      // Wallet is already locked, stop the alarm
      await stopAutoLockAlarm();
      console.log('[AutoLock] Alarm stopped - wallet already locked');
      return;
    }

    const lastActivity = data.lastActivity || 0;
    const elapsed = Date.now() - lastActivity;

    console.log(`[AutoLock] Alarm check - elapsed: ${Math.floor(elapsed / 1000)}s / ${AUTO_LOCK_DELAY_MS / 1000}s`);

    // Check if 15 minutes have elapsed since last activity
    if (elapsed > AUTO_LOCK_DELAY_MS) {
      console.log('â° [AutoLock] 15 MINUTES ELAPSED - locking wallet');

      // Lock the wallet
      await chrome.storage.local.set({ isUnlocked: false });

      // Stop the alarm
      await stopAutoLockAlarm();

      // Send message to popup if it's open to update UI
      try {
        await chrome.runtime.sendMessage({ type: 'WALLET_LOCKED_AUTO' });
      } catch (error) {
        // Popup not open, that's fine
        console.log('[AutoLock] Popup not open, wallet locked in storage only');
      }
    }
  } catch (error) {
    console.error('[AutoLock] Alarm check error:', error);
  }
});

// Listen for wallet unlock to start alarm
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'START_AUTO_LOCK_ALARM') {
    startAutoLockAlarm();
    sendResponse({ success: true });
    return true;
  }

  if (message.type === 'STOP_AUTO_LOCK_ALARM') {
    stopAutoLockAlarm();
    sendResponse({ success: true });
    return true;
  }
});